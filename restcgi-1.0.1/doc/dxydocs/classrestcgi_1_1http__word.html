<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>restcgi: restcgi::http_word Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespacerestcgi.html">restcgi</a>::<a class="el" href="classrestcgi_1_1http__word.html">http_word</a></div>
<h1>restcgi::http_word Class Reference</h1><!-- doxytag: class="restcgi::http_word" --><a href="classrestcgi_1_1http__word-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
HTTP/1.1 specification "word", either a "token" or quoted text. 
<p>
This is meant for converting strings with spaces and special chars, e.g. ';', into a single "word" for HTTP "value" type fields. When encoding words, if the string parses as a "token" it is returned as is, otherwise it is quoted, escaping any embedded '\' or '"' chars.<p>
Note: An alternative to this is to perform a "generic" URI percent-encoding along the lines of the JavaScript encode() function, producing a "token" instead of a "quoted-string". However, the JavaScript functions will allow (i.e. not encode) some chars that are invalid as "token" chars. Depending on the context these differences may or may not cause problems.<ul>
<li>
JavaScript encode(): allows fewer chars than "token" but conflicts by allowing forward slash and at symbol. This is frequently used to set cookie values from within the browser. </li>
<li>
JavaScript encodeURIComponent(): allows fewer chars than "token" but conflicts by allowing left and right parens. </li>
</ul>
<p>
There is no standard solution to the encoding problem. Applications that share data must be explicitly programmed to do so. In other words, using this class for both encoding and decoding will work, interoperability with other applications (without explicit, additional programming) is not guaranteed.<p>
Syntax (see <a class="el" href="classrestcgi_1_1http__token.html">http_token</a>, <a class="el" href="classrestcgi_1_1http__text.html">http_text</a> for additional definitions): <pre>
 word          = token | quoted-string
 quoted-string = ( &lt;"&gt; *(qdtext | quoted-pair ) \&lt;"&gt; )
 qdtext        = &lt;any TEXT except &lt;"&gt;&gt;
 quoted-pair   = "\" CHAR
 </pre><p>
Notes on quoted-string:<ul>
<li>
'\' is used as an escape for any char (0-0x7F) that follows it, and, thus, the '\' will be removed. </li>
<li>
CTL chars (including HT) are not allowed, escaped or not, and will cause a return of false if encountered before the ending quote. </li>
<li>
The char after the ending quote is not checked in any way. </li>
<li>
Chars from other charsets not supported, i.e. RFC2047 is not supported. </li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classrestcgi_1_1http__token.html">http_token</a>, <a class="el" href="classrestcgi_1_1http__text.html">http_text</a>, <a class="el" href="classrestcgi_1_1http__word.html#a2f307794614fabc27eca2bb43a1a3bc">parse(std::string::const_iterator&amp;, std::string::const_iterator, http_word&amp;)</a> <p>
<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2">http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2</a> </dd></dl>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrestcgi_1_1http__word.html#6884161f07c88af406ff44aef6a10268">http_word</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrestcgi_1_1http__word.html#0fabe38c06c67fa450eef5630415b32d">http_word</a> (const std::string &amp;s)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4e6e43599bc87a71d8d70a43dd7c4fc5"></a><!-- doxytag: member="restcgi::http_word::http_word" ref="4e6e43599bc87a71d8d70a43dd7c4fc5" args="(const http_token &amp;tok)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrestcgi_1_1http__word.html#4e6e43599bc87a71d8d70a43dd7c4fc5">http_word</a> (const <a class="el" href="classrestcgi_1_1http__token.html">http_token</a> &amp;tok)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct from HTTP token. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2684ed84005a89155d05d19e91bdc782"></a><!-- doxytag: member="restcgi::http_word::http_word" ref="2684ed84005a89155d05d19e91bdc782" args="(const http_text &amp;txt)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrestcgi_1_1http__word.html#2684ed84005a89155d05d19e91bdc782">http_word</a> (const <a class="el" href="classrestcgi_1_1http__text.html">http_text</a> &amp;txt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct from HTTP text. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrestcgi_1_1http__word.html#fdd27f775a2c0b4713cf21947ea2610c">empty</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrestcgi_1_1http__word.html#3d56cfcbf1a0267434d5b347c8c81550">string</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classrestcgi_1_1http__word.html">http_word</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrestcgi_1_1http__word.html#415690fbbe0cd58edee9708c83217a6d">operator+</a> (const std::string &amp;rhs) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classrestcgi_1_1http__word.html">http_word</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrestcgi_1_1http__word.html#30d6b8d19cc0d5fd14addf8d0dd36d82">operator+=</a> (const std::string &amp;rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cb8fa63ca7c8b0e6889ccd6034671299"></a><!-- doxytag: member="restcgi::http_word::operator+" ref="cb8fa63ca7c8b0e6889ccd6034671299" args="(const http_text &amp;rhs) const " -->
<a class="el" href="classrestcgi_1_1http__word.html">http_word</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrestcgi_1_1http__word.html#cb8fa63ca7c8b0e6889ccd6034671299">operator+</a> (const <a class="el" href="classrestcgi_1_1http__text.html">http_text</a> &amp;rhs) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append text and return result. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classrestcgi_1_1http__word.html">http_word</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrestcgi_1_1http__word.html#abd59c720fb497c88726a5e2d319751a">operator+=</a> (const <a class="el" href="classrestcgi_1_1http__text.html">http_text</a> &amp;rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="405e6e67d81283b204fd888126c71680"></a><!-- doxytag: member="restcgi::http_word::operator+" ref="405e6e67d81283b204fd888126c71680" args="(const http_word &amp;rhs) const " -->
<a class="el" href="classrestcgi_1_1http__word.html">http_word</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrestcgi_1_1http__word.html#405e6e67d81283b204fd888126c71680">operator+</a> (const <a class="el" href="classrestcgi_1_1http__word.html">http_word</a> &amp;rhs) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append word and return result. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classrestcgi_1_1http__word.html">http_word</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrestcgi_1_1http__word.html#b3985c1e1af64923ec118e3a26e8177f">operator+=</a> (const <a class="el" href="classrestcgi_1_1http__word.html">http_word</a> &amp;rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrestcgi_1_1http__word.html#8c221bc6143cea4299b8829e3208d042">encoding</a> (bool force_quotes=false) const </td></tr>

<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c3b8ba84bf330399d8253f6348e847e8"></a><!-- doxytag: member="restcgi::http_word::ESC_CHAR" ref="c3b8ba84bf330399d8253f6348e847e8" args="" -->
static const char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrestcgi_1_1http__word.html#c3b8ba84bf330399d8253f6348e847e8">ESC_CHAR</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">escape char ('\') <br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool RESTCGI_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrestcgi_1_1http__word.html#a2f307794614fabc27eca2bb43a1a3bc">parse</a> (std::string::const_iterator &amp;first, std::string::const_iterator last, <a class="el" href="classrestcgi_1_1http__word.html">http_word</a> &amp;v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse HTTP word.  <a href="#a2f307794614fabc27eca2bb43a1a3bc"></a><br></td></tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="6884161f07c88af406ff44aef6a10268"></a><!-- doxytag: member="restcgi::http_word::http_word" ref="6884161f07c88af406ff44aef6a10268" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">restcgi::http_word::http_word           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct. 
</div>
</div><p>
<a class="anchor" name="0fabe38c06c67fa450eef5630415b32d"></a><!-- doxytag: member="restcgi::http_word::http_word" ref="0fabe38c06c67fa450eef5630415b32d" args="(const std::string &amp;s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">restcgi::http_word::http_word           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct from encoded string, either <a class="el" href="classrestcgi_1_1http__token.html">http_token</a> or quoted <a class="el" href="classrestcgi_1_1http__text.html">http_text</a>. <dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>if string not valid word </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="fdd27f775a2c0b4713cf21947ea2610c"></a><!-- doxytag: member="restcgi::http_word::empty" ref="fdd27f775a2c0b4713cf21947ea2610c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool restcgi::http_word::empty           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test empty. 
</div>
</div><p>
<a class="anchor" name="8c221bc6143cea4299b8829e3208d042"></a><!-- doxytag: member="restcgi::http_word::encoding" ref="8c221bc6143cea4299b8829e3208d042" args="(bool force_quotes=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string restcgi::http_word::encoding           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>force_quotes</em> = <code>false</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate the encoding for the word, returning just the string if a token, otherwise quoting and escaping. 
</div>
</div><p>
<a class="anchor" name="415690fbbe0cd58edee9708c83217a6d"></a><!-- doxytag: member="restcgi::http_word::operator+" ref="415690fbbe0cd58edee9708c83217a6d" args="(const std::string &amp;rhs) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrestcgi_1_1http__word.html">http_word</a> restcgi::http_word::operator+           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Append (and check) text string and return result. <dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>if string contains invalid text chars </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b3985c1e1af64923ec118e3a26e8177f"></a><!-- doxytag: member="restcgi::http_word::operator+=" ref="b3985c1e1af64923ec118e3a26e8177f" args="(const http_word &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrestcgi_1_1http__word.html">http_word</a>&amp; restcgi::http_word::operator+=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrestcgi_1_1http__word.html">http_word</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Append word to this and return this. 
</div>
</div><p>
<a class="anchor" name="abd59c720fb497c88726a5e2d319751a"></a><!-- doxytag: member="restcgi::http_word::operator+=" ref="abd59c720fb497c88726a5e2d319751a" args="(const http_text &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrestcgi_1_1http__word.html">http_word</a>&amp; restcgi::http_word::operator+=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrestcgi_1_1http__text.html">http_text</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Append text to this and return this. 
</div>
</div><p>
<a class="anchor" name="30d6b8d19cc0d5fd14addf8d0dd36d82"></a><!-- doxytag: member="restcgi::http_word::operator+=" ref="30d6b8d19cc0d5fd14addf8d0dd36d82" args="(const std::string &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrestcgi_1_1http__word.html">http_word</a>&amp; restcgi::http_word::operator+=           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Append (and check) text string to this and return this. <dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>if string contains invalid text chars </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3d56cfcbf1a0267434d5b347c8c81550"></a><!-- doxytag: member="restcgi::http_word::string" ref="3d56cfcbf1a0267434d5b347c8c81550" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; restcgi::http_word::string           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get (unencoded) string. This is either the token or the unquoted (unfolded) text. 
</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="a2f307794614fabc27eca2bb43a1a3bc"></a><!-- doxytag: member="restcgi::http_word::parse" ref="a2f307794614fabc27eca2bb43a1a3bc" args="(std::string::const_iterator &amp;first, std::string::const_iterator last, http_word &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RESTCGI_API parse           </td>
          <td>(</td>
          <td class="paramtype">std::string::const_iterator &amp;&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::const_iterator&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrestcgi_1_1http__word.html">http_word</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse HTTP word. 
<p>
Returns whether found or not and advances first and sets if found. Skips leading SP or HT chars. 
</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Mon May 18 16:03:19 2009 for restcgi by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
